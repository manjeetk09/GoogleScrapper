Depth First Traversal (or Search) for a graph is similar to Depth First Traversal of a tree.
No extractions found.

 The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again.
0.694: (The only catch; here is may contain cycles unlike; trees)
0.606: (The only catch; here is may contain; cycles)
0.571: (we; so may come again to; the same node)
0.485: (cycles; here is may contain unlike; trees)
0.392: (graphs; here is may contain; cycles)
0.318: (graphs; here is may contain cycles unlike; trees)

 To avoid processing a node more than once, we use a boolean visited array.
0.658: (we; use; a boolean visited array)

 For example, in the following graph, we start traversal from vertex 2.
0.639: (we; start; traversal)
0.45: (we; start traversal from vertex in; the following graph)
0.186: (we; start traversal from vertex for; example)

 When we come to vertex 0, we look for all adjacent vertices of it.
0.769: (we; look for; all adjacent vertices of it)

 2 is also an adjacent vertex of 0.
0.853: (2; is also an adjacent vertex of; 0.)
0.665: (2; is also; an adjacent vertex of 0.)

 If we donâ€™t mark visited vertices, then 2 will be processed again and it will become a non-terminating process.
0.501: (it; will will become; a non-terminating process)
0.059: (we; do n't mark; visited vertices)

 A Depth First Traversal of the following graph is 2, 0, 1, 3.
0.662: (A Depth First Traversal of the following graph; is; 2)

Depth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration.
0.847: (a dead end; occurs in; any iteration)
0.729: (the next vertex; to start; a search)[enabler=when a dead end occurs in any iteration]

