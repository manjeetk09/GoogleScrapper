In this section we present two algorithms for exploring a graph, starting at one of its vertices, , and finding all vertices that are reachable from .
0.739: (we; present; two algorithms)
0.5: (we; finding; all vertices that are reachable from)
0.492: (we; present two algorithms for exploring a graph starting at; one of its vertices)
0.38: (we; present two algorithms for exploring a graph in; this section)

 Both of these algorithms are best suited to graphs represented using an adjacency list representation.
No extractions found.

 Therefore, when analyzing these algorithms we will assume that the underlying representation is an AdjacencyLists.
0.598: (the underlying representation; is; an Adjacency Lists)

This algorithm is a generalization of the breadth-first traversal algorithm for binary trees (SectionÂ 6.
0.939: (This algorithm; is a generalization of; the breadth-first traversal algorithm)
0.804: (This algorithm; is; a generalization of the breadth-first traversal algorithm)

1.
No extractions found.

2), and is very similar; it uses a queue, , that initially contains only .
0.625: (it; uses; a queue)

 It then repeatedly extracts an element from and adds its neighbours to , provided that these neighbours have never been in before.
0.767: (It; then repeatedly extracts; an element)

 The only major difference between the breadth-first-search algorithm for graphs and the one for trees is that the algorithm for graphs has to ensure that it does not add the same vertex to more than once.
0.606: (it; does not add; the same vertex)
0.542: (the algorithm; is in; one)
0.539: (one; be the breadth-first-search algorithm for; graphs)

 It does this by using an auxiliary boolean array, , that tracks which vertices have already been discovered.
No extractions found.

