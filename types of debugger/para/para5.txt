

By Howard Rubin, July 09, 2013








Figure 1: The Affinic debugger.
Figure 1: The Affinic debugger.
Figure 2: Code::Blocks.
Figure 2: Code::Blocks.
Figure 2: Code::Blocks.
Figure 3: Codelite 5.1.
Figure 3: Codelite 5.1.
Figure 3: Codelite 5.1.
Figure 4: Gnu DDD.
Figure 4: Gnu DDD.
Figure 5: Eclipse (Juno release) front-ending gdb.
Figure 5: Eclipse (Juno release) front-ending gdb.
Figure 6: GNU Emacs' GDB mode.
Figure 6: GNU Emacs' GDB mode.
Figure 7: The KDevelop debugger.
Figure 7: The KDevelop debugger.
Figure 8: Nemiver.
Figure 8: Nemiver.








Many Eclipse perspectives, e.g. the Java Development Tools (JDT), provide a debugger front-end. Allinea DDT - a graphical debugger supporting for parallel/multi-process and multithreaded applications, for C++/C++ and F90. DDD is the standard front-end from the GNU Project. It is a complex tool that works with most common debuggers (GDB, jdb, Python debugger, Perl debugger, Tcl, and others) natively or with some external programs (for PHP). GDB (the GNU debugger) GUI Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Many Eclipse perspectives, e.g. the Java Development Tools (JDT), provide a debugger front-end. Allinea DDT - a graphical debugger supporting for parallel/multi-process and multithreaded applications, for C++/C++ and F90. DDD is the standard front-end from the GNU Project. It is a complex tool that works with most common debuggers (GDB, jdb, Python debugger, Perl debugger, Tcl, and others) natively or with some external programs (for PHP). GDB (the GNU debugger) GUI Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Many Eclipse perspectives, e.g. the Java Development Tools (JDT), provide a debugger front-end. Allinea DDT - a graphical debugger supporting for parallel/multi-process and multithreaded applications, for C++/C++ and F90. DDD is the standard front-end from the GNU Project. It is a complex tool that works with most common debuggers (GDB, jdb, Python debugger, Perl debugger, Tcl, and others) natively or with some external programs (for PHP). GDB (the GNU debugger) GUI Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Many Eclipse perspectives, e.g. the Java Development Tools (JDT), provide a debugger front-end. Allinea DDT - a graphical debugger supporting for parallel/multi-process and multithreaded applications, for C++/C++ and F90. DDD is the standard front-end from the GNU Project. It is a complex tool that works with most common debuggers (GDB, jdb, Python debugger, Perl debugger, Tcl, and others) natively or with some external programs (for PHP). GDB (the GNU debugger) GUI Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution
Emacs — Emacs editor with built-in support for the GNU Debugger acts as the frontend. KDbg — Part of the KDE development tools. Nemiver — A GDB frontend that integrates well in the GNOME desktop environment. xxgdb — X-window frontend for GDB and dbx debugger. Qt Creator — multi-platform frontend for GDB, CDB and LLDB. Allinea's DDT — a parallel and distributed front-end to a modified version of GDB. Xcode — contains a GDB front-end as well. SlickEdit — contains a GDB front-end as well. Eclipse C/C++ Development Tools (CDT) — includes visual debugging tools based on GDB. CodeLite — An open source, cross platform C/C++ IDE which have front end for gdb, the next version of CodeLite (v6.0) will also include a front end to the LLDB (debugger) CodeBlocks — A free cross-platform C, C++ and Fortran IDE with a front end for gdb. RR — An open source C/C++ debugger by Mozilla, supporting reproduction of program state and reverse execution




The same mode is also used by KGDB for debugging a running Linux kernel on the source level with gdb. With KGDB, kernel developers can debug a kernel in much the same way as they debug application programs. It makes it possible to place breakpoints in kernel code, step through the code and observe variables. On architectures where hardware debugging registers are available, watchpoints can be set which trigger breakpoints when specified memory addresses are executed or accessed. KGDB requires an additional machine which is connected to the machine to be debugged using a serial cable or Ethernet. On FreeBSD, it is also possible to debug using Firewire direct memory access (DMA).
The same mode is also used by KGDB for debugging a running Linux kernel on the source level with gdb. With KGDB, kernel developers can debug a kernel in much the same way as they debug application programs. It makes it possible to place breakpoints in kernel code, step through the code and observe variables. On architectures where hardware debugging registers are available, watchpoints can be set which trigger breakpoints when specified memory addresses are executed or accessed. KGDB requires an additional machine which is connected to the machine to be debugged using a serial cable or Ethernet. On FreeBSD, it is also possible to debug using Firewire direct memory access (DMA).
The same mode is also used by KGDB for debugging a running Linux kernel on the source level with gdb. With KGDB, kernel developers can debug a kernel in much the same way as they debug application programs. It makes it possible to place breakpoints in kernel code, step through the code and observe variables. On architectures where hardware debugging registers are available, watchpoints can be set which trigger breakpoints when specified memory addresses are executed or accessed. KGDB requires an additional machine which is connected to the machine to be debugged using a serial cable or Ethernet. On FreeBSD, it is also possible to debug using Firewire direct memory access (DMA).
The same mode is also used by KGDB for debugging a running Linux kernel on the source level with gdb. With KGDB, kernel developers can debug a kernel in much the same way as they debug application programs. It makes it possible to place breakpoints in kernel code, step through the code and observe variables. On architectures where hardware debugging registers are available, watchpoints can be set which trigger breakpoints when specified memory addresses are executed or accessed. KGDB requires an additional machine which is connected to the machine to be debugged using a serial cable or Ethernet. On FreeBSD, it is also possible to debug using Firewire direct memory access (DMA).
The same mode is also used by KGDB for debugging a running Linux kernel on the source level with gdb. With KGDB, kernel developers can debug a kernel in much the same way as they debug application programs. It makes it possible to place breakpoints in kernel code, step through the code and observe variables. On architectures where hardware debugging registers are available, watchpoints can be set which trigger breakpoints when specified memory addresses are executed or accessed. KGDB requires an additional machine which is connected to the machine to be debugged using a serial cable or Ethernet. On FreeBSD, it is also possible to debug using Firewire direct memory access (DMA).
The same mode is also used by KGDB for debugging a running Linux kernel on the source level with gdb. With KGDB, kernel developers can debug a kernel in much the same way as they debug application programs. It makes it possible to place breakpoints in kernel code, step through the code and observe variables. On architectures where hardware debugging registers are available, watchpoints can be set which trigger breakpoints when specified memory addresses are executed or accessed. KGDB requires an additional machine which is connected to the machine to be debugged using a serial cable or Ethernet. On FreeBSD, it is also possible to debug using Firewire direct memory access (DMA).
v t e
v t e
v t e


This article examines three different types of debuggers: source-level debuggers, memory debuggers and bug tracking software.
This article examines three different types of debuggers: source-level debuggers, memory debuggers and bug tracking software.
DDD binaries for GNU/Linux are typically available via your GNU/Linux distributor: DDD packages for Debian GNU/Linux are found here.. DDD RPMs can be found in http://rpmfind.net/linux/rpm2html/search.php?query=ddd..
DDD binaries for GNU/Linux are typically available via your GNU/Linux distributor: DDD packages for Debian GNU/Linux are found here.. DDD RPMs can be found in http://rpmfind.net/linux/rpm2html/search.php?query=ddd..
DDD binaries for GNU/Linux are typically available via your GNU/Linux distributor: DDD packages for Debian GNU/Linux are found here.. DDD RPMs can be found in http://rpmfind.net/linux/rpm2html/search.php?query=ddd..
DDD binaries for GNU/Linux are typically available via your GNU/Linux distributor: DDD packages for Debian GNU/Linux are found here.. DDD RPMs can be found in http://rpmfind.net/linux/rpm2html/search.php?query=ddd..
DDD binaries for GNU/Linux are typically available via your GNU/Linux distributor: DDD packages for Debian GNU/Linux are found here.. DDD RPMs can be found in http://rpmfind.net/linux/rpm2html/search.php?query=ddd..
DDD binaries for GNU/Linux are typically available via your GNU/Linux distributor: DDD packages for Debian GNU/Linux are found here.. DDD RPMs can be found in http://rpmfind.net/linux/rpm2html/search.php?query=ddd..
°C++ Info, links
Page last modified: April 7, 2004
Page last modified: April 7, 2004
KDbg
KDbg is a graphical user interface to gdb, the GNU debugger. It provides an intuitive interface for setting breakpoints, inspecting variables, and stepping through code.
KDbg is a graphical user interface to gdb, the GNU debugger. It provides an intuitive interface for setting breakpoints, inspecting variables, and stepping through code.
Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings.
Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings.
Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings.
Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings.
Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings.
Inspection of variable values in a tree structure. Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings. Debugger at your finger tips: The basic debugger functions (step, next, run, finish, until, set/clear/enable/disable breakpoint) are bound to function keys F5 through F10. Quick and easy. Of course, lots of other basic functions: View source code, search text, set program arguments and environment variables, display arbitrary expressions. Everything you need to debug a program! Debugging of core dumps, attaching to running processes is possible. Conditional breakpoints.
Inspection of variable values in a tree structure. Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings. Debugger at your finger tips: The basic debugger functions (step, next, run, finish, until, set/clear/enable/disable breakpoint) are bound to function keys F5 through F10. Quick and easy. Of course, lots of other basic functions: View source code, search text, set program arguments and environment variables, display arbitrary expressions. Everything you need to debug a program! Debugging of core dumps, attaching to running processes is possible. Conditional breakpoints.
Inspection of variable values in a tree structure. Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings. Debugger at your finger tips: The basic debugger functions (step, next, run, finish, until, set/clear/enable/disable breakpoint) are bound to function keys F5 through F10. Quick and easy. Of course, lots of other basic functions: View source code, search text, set program arguments and environment variables, display arbitrary expressions. Everything you need to debug a program! Debugging of core dumps, attaching to running processes is possible. Conditional breakpoints.
Inspection of variable values in a tree structure. Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings. Debugger at your finger tips: The basic debugger functions (step, next, run, finish, until, set/clear/enable/disable breakpoint) are bound to function keys F5 through F10. Quick and easy. Of course, lots of other basic functions: View source code, search text, set program arguments and environment variables, display arbitrary expressions. Everything you need to debug a program! Debugging of core dumps, attaching to running processes is possible. Conditional breakpoints.
Inspection of variable values in a tree structure. Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings. Debugger at your finger tips: The basic debugger functions (step, next, run, finish, until, set/clear/enable/disable breakpoint) are bound to function keys F5 through F10. Quick and easy. Of course, lots of other basic functions: View source code, search text, set program arguments and environment variables, display arbitrary expressions. Everything you need to debug a program! Debugging of core dumps, attaching to running processes is possible. Conditional breakpoints.
Inspection of variable values in a tree structure. Direct member: For certain compound data types the most important member values are displayed next to the variable name, so that it is not necessary to expand the subtree of that variable in order to see the member value. For example, you don't need to go into a variable of type QString if you want to see the string that the variable holds. (BTW, this is of course not hardcoded, but can be extended to new types.) KDbg can even display Qt's QString values, which are Unicode strings. Debugger at your finger tips: The basic debugger functions (step, next, run, finish, until, set/clear/enable/disable breakpoint) are bound to function keys F5 through F10. Quick and easy. Of course, lots of other basic functions: View source code, search text, set program arguments and environment variables, display arbitrary expressions. Everything you need to debug a program! Debugging of core dumps, attaching to running processes is possible. Conditional breakpoints.
