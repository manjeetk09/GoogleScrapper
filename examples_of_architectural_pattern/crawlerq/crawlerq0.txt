v.
t.
e.
.
.
Some additional examples of architectural patterns.
 Blackboard system.
 Broker pattern.
 Event_driven architecture.
 Implicit invocation.
 Layers.
 Microservices.
 Model_view_controller, Presentation_abstraction_control, Model_view_presenter, and Model_view_viewmodel.
 Multitier architecture .
 Naked objects.
 Operational Data Store .
 Peer_to_peer.
 Pipe and filter architecture.
 Service_oriented architecture.
v.
t.
e.
.
.
Several different formats are used in the literature for describing patterns, and no single format has achieved widespread acceptance.
 However, there is broad agreement on the types of things that a pattern should contain.
 The headings which follow are taken from Pattern_Oriented Software Architecture.
 A System of Patterns, by F.
 Buschmann, R.
 Meunier, H.
 Rohnert, P.
Sommerlad, and M.
 Stal, John Wiley and Sons, 1996, ISBN 0_471_95869_7.
 The elements described below will be found in most patterns, even if different headings are used to describe them.
 Name.
 A meaningful and memorable way to refer to the pattern, typically a single word or short phrase.
 Problem.
   A description of the problem indicating the intent in applying the pattern _ the intended goals and objectives to be reached within the context and forces described below   .
 Context.
   The pre_conditions under which the pattern is applicable _ a description of the initial state before the pattern is applied.
 Forces.
 A description of the relevant forces and constraints, and how they interact conflict with each other and with the intended goals and objectives.
 The description should clarify the intricacies of the problem and make explicit the kinds of trade_offs that must be considered.
  The need for such trade_offs is typically what makes the problem difficult, and generates the need for the pattern, in the first place.
  The notion of  forces  equates in many ways to the  qualities  that architects seek to optimize, and the concerns they seek to address, in designing architectures.
 For example.
 Security, robustness, reliability, fault_tolerance Manageability Efficiency, performance, throughout, bandwidth requirements, space utilization Scalability Extensibility, evolvability, maintainability Modularity, independence, reusability, openness, composability , portability Completeness and correctness Ease of construction Ease of use .
 etc.
 Solution.
 A description, using text and or graphics, of how to achieve the intended goals and objectives.
 The description should identify both the solution s static structure and its dynamic behavior _ the people and computing actors, and their collaborations.
 The description may include guidelines for implementing the solution.
 Variants or specializations of the solution may also be described.
 Resulting Context.
 The post_conditions after the pattern has been applied.
 Implementing the solution normally requires trade_offs among competing forces.
 This element describes which forces have been resolved and how, and which remain unresolved.
 It may also indicate other patterns that may be applicable in the new context.
  A pattern may be one step in accomplishing some larger goal.
  Any such other patterns will be described in detail under Related Patterns.
 Examples.
 One or more sample applications of the pattern which illustrate each of the other elements.
 a specific problem, context, and set of forces  how the pattern is applied  and the resulting context.
 Rationale.
 An explanation   justification of the pattern as a whole, or of individual components within it, indicating how the pattern actually works, and why _ how it resolves the forces to achieve the desired goals and objectives, and why this is  good .
 The Solution element of a pattern describes the external structure and behavior of the solution.
 the Rationale provides insight into its internal workings.
 Related Patterns.
 The relationships between this pattern and others.
 These may be predecessor patterns, whose resulting contexts correspond to the initial context of this one  or successor patterns, whose initial contexts correspond to the resulting context of this one  or alternative patterns, which describe a different solution to the same problem, but under different forces  or co_dependent patterns, which may   must be applied along with this pattern.
 Known Uses.
 Known applications of the pattern within existing systems, verifying that the pattern does indeed describe a proven solution to a recurring problem.
 Known Uses can also serve as Examples.
.
This chapter describes and discusses high level patterns and principles commonly used for applications today.
 These are often referred to as the architectural styles, and include patterns such as client server, layered architecture, component_based architecture, message bus architecture, and service_oriented architecture .
 For each style, you will find an overview, key principles, major benefits, and information that will help you choose the appropriate architectural styles for your application.
 It is important to understand that the styles describe different aspects of applications.
 For example, some architectural styles describe deployment patterns, some describe structure and design issues, and others describe communication factors.
 Therefore, a typical application will usually use a combination of more than one of the styles described in this chapter.
