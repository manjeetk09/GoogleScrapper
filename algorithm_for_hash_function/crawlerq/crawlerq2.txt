By Bob Jenkins, September 01, 1997.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
By John Boyer, January 01, 1998.
.
.
.
.
.
.
.
.
More recently, Bob Jenkins presented a hashing function that performs a complex mixing operation using 12 bytes at a time from the input key.
 By design, the bytes of the key have some affect on all regions of the hash value.
 Thus, the hash function suffers little or no information loss when the hash value is truncated to the table size.
 As Table 1 shows, the efficiency of Jenkins  hash function was far greater than the original HashPJW, and even slightly better than HashJBand the new HashPJW.
 The run time using HashJBis equivalent to HashJenkinsbecause the former uses slightly less CPU time to compute hash values.
DDJ.
.
.
.
.
.
.
.
.
The Jenkins hash functions are a collection of hash functions for multi_byte keys designed by Bob Jenkins.
 The first one was formally published in 1997.
       .
.
.
       .
.
.
       .
.
.
I offer you a new hash function for hash table lookup that is faster and more thorough than the one you are using now.
 I also give you a way to verify that it is more thorough.
I have three complaints against it.
 First, it s specific about how to reduce the size if you don t use all the bits, it s not just a mask.
 Increasing the result size by one bit gives you a completely different hash.
 If you use a hash table that grows by increasing the result size by one bit, one old bucket maps across the entire new table, not to just two new buckets.
 If your algorithm has a sliding pointer for which buckets have been split, that just won t work with FNV.
 Second, it s linear.
 That means that widely separated things can cancel each other out at least as easily as nearby things.
 Third, since multiplication only affects higher bits, the lowest 7 bits of the state are never affected by the 8th bit of all the input bytes.
The BDZ algorithm uses r_uniform random hypergraphs given by function values of r uniform random hash functions on the input key set S for generating PHFs and MPHFs that require Obits to be stored.
 A hypergraph is the generalization of a standard undirected graph where each edge connects vertices.
 This idea is not new, see e.
g.
 , but we have proceeded differently to achieve a space usage of Obits rather than Obits.
 Evaluation time for all schemes considered is constant.
 For r 3 we obtain a space usage of approximately 2.
6n bits for an MPHF.
 More compact, and even simpler, representations can be achieved for larger m.
 For example, for m 1.
23n we can get a space usage of 1.
95n bits.
