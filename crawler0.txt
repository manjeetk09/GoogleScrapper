A database model is a type of data model that determines the logical structure of a database and fundamentally determines in which manner data can be stored, organized and manipulated.
 The most popular example of a database model is the relational model, which uses a table_based format.
.
.
Common logical data models for databases include .
An object_relational database combines the two related structures.
Physical data models include .
Other models include .
A given database management system may provide one or more models.
 The optimal structure depends on the natural organization of the application s data, and on the application s requirements, which include transaction rate , reliability, maintainability, scalability, and cost.
 Most database management systems are built around one particular data model, although it is possible for products to offer support for more than one model.
Various physical data models can implement any given logical model.
 Most database software will offer the user some level of control in tuning the physical implementation, since the choices that are made have a significant effect on performance.
A model is not just a way of structuring data  it also defines a set of operations that can be performed on the data.
 The relational model, for example, defines operations such as select and join.
 Although these operations may not be explicit in a particular query language, they provide the foundation on which a query language is built.
The flat model consists of a single, two_dimensional array of data elements, where all members of a given column are assumed to be similar values, and all members of a row are assumed to be related to one another.
 For instance, columns for name and password that might be used as a part of a system security database.
 Each row would have the specific password associated with an individual user.
 Columns of the table often have a type associated with them, defining them as character data, date or time information, integers, or floating point numbers.
 This tabular format is a precursor to the relational model.
These models were popular in the 1960s, 1970s, but nowadays can be found primarily in old legacy systems.
 They are characterized primarily by being navigational with strong connections between their logical and physical representations, and deficiencies in data independence.
In a hierarchical model, data is organized into a tree_like structure, implying a single parent for each record.
 A sort field keeps sibling records in a particular order.
 Hierarchical structures were widely used in the early mainframe database management systems, such as the Information Management System by IBM, and now describe the structure of XML documents.
 This structure allows one one_to_many relationship between two types of data.
 This structure is very efficient to describe many relationships in the real world  recipes, table of contents, ordering of paragraphs verses, any nested and sorted information.
This hierarchy is used as the physical order of records in storage.
 Record access is done by navigating downward through the data structure using pointers combined with sequential accessing.
 Because of this, the hierarchical structure is inefficient for certain database operations when a full path is not also included for each record.
 Such limitations have been compensated for in later IMS versions by additional logical hierarchies imposed on the base physical hierarchy.
The network model expands upon the hierarchical structure, allowing many_to_many relationships in a tree_like structure that allows multiple parents.
 It was most popular before being replaced by the relational model, and is defined by the CODASYL specification.
The network model organizes data using two fundamental concepts, called records and sets.
 Records contain fields .
 Sets define one_to_many relationships between records  one owner, many members.
 A record may be an owner in any number of sets, and a member in any number of sets.
A set consists of circular linked lists where one record type, the set owner or parent, appears once in each circle, and a second record type, the subordinate or child, may appear multiple times in each circle.
 In this way a hierarchy may be established between any two record types, e.
g.
, type A is the owner of B.
 At the same time another set may be defined where B is the owner of A.
 Thus all the sets comprise a general directed graph , or network construct.
 Access to records is either sequential or by navigation in the circular linked lists.
The network model is able to represent redundancy in data more efficiently than in the hierarchical model, and there can be more than one path from an ancestor node to a descendant.
 The operations of the network model are navigational in style  a program maintains a current position, and navigates from one record to another by following the relationships in which the record participates.
 Records can also be located by supplying key values.
Although it is not an essential feature of the model, network databases generally implement the set relationships by means of pointers that directly address the location of a record on disk.
 This gives excellent retrieval performance, at the expense of operations such as database loading and reorganization.
Popular DBMS products that utilized it were Cincom Systems  Total and Cullinet s IDMS.
 IDMS gained a considerable customer base  in the 1980s, it adopted the relational model and SQL in addition to its original tools and languages.
Most object databases use the navigational concept to provide fast navigation across networks of objects, generally using object identifiers as  smart  pointers to related objects.
 Objectivity DB, for instance, implements named one_to_one, one_to_many, many_to_one, and many_to_many named relationships that can cross databases.
 Many object databases also support SQL, combining the strengths of both models.
In an inverted file or inverted index, the contents of the data are used as keys in a lookup table, and the values in the table are pointers to the location of each instance of a given content item.
 This is also the logical structure of contemporary database indexes, which might only use the contents from a particular columns in the lookup table.
 The inverted file data model can put indexes in a second set of files next to existing flat database files, in order to efficiently directly access needed records in these files.
Notable for using this data model is the ADABAS DBMS of Software AG, introduced in 1970.
 ADABAS has gained considerable customer base and exists and supported until today.
 In the 1980s it has adopted the relational model and SQL in addition to its original tools and languages.
Document_oriented database Clusterpoint uses inverted indexing model to provide fast full_text search for XML or JSON data objects and to deliver scale out ability for Big data.
 Clusterpoint has built_in computing engine that allows execution of a combined SQL query, free text search and JavaScript code right inside the distributed database.
 Both data and inverted index through scalable sharding and replication can be distributed across a large number of servers to support billions of data objects in the same Clusterpoint database.
 Clusterpoint query language JS SQL blends together SQL and JavaScript syntax with full text search, where inverted index is being used to deliver milliseconds_range text search performance and relevant pagination in web and mobile applications.
 In Clusterpoint database architecture inverted index also supports programmable relevance ranking enabling to customize search output without extra coding efforts.
 Similarly to relational databases, Clusterpoint supports distributed ACID_compliant database transactions for strong document database consistency, where inverted index data is immediately updated along any XML or JSON document content updates.
 Inverted index is also used to support near real_time Big data reporting, analytics, drill_down and data mining over REST API in Clusterpoint database.
The relational model was introduced by E.
F.
 Cod