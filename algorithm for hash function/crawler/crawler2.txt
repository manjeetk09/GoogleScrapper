0;By Bob Jenkins, September 01, 1997.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;By John Boyer, January 01, 1998.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;More recently, Bob Jenkins presented a hashing function that performs a complex mixing operation using 12 bytes at a time from the input key.
0; By design, the bytes of the key have some affect on all regions of the hash value.
0; Thus, the hash function suffers little or no information loss when the hash value is truncated to the table size.
0; As Table 1 shows, the efficiency of Jenkins  hash function was far greater than the original HashPJW, and even slightly better than HashJBand the new HashPJW.
0; The run time using HashJBis equivalent to HashJenkinsbecause the former uses slightly less CPU time to compute hash values.
0;DDJ.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;.
0;The Jenkins hash functions are a collection of hash functions for multi_byte keys designed by Bob Jenkins.
0; The first one was formally published in 1997.
0;       .
0;.
0;.
0;       .
0;.
0;.
0;       .
0;.
0;.
0;I offer you a new hash function for hash table lookup that is faster and more thorough than the one you are using now.
0; I also give you a way to verify that it is more thorough.
0;I have three complaints against it.
0; First, it s specific about how to reduce the size if you don t use all the bits, it s not just a mask.
0; Increasing the result size by one bit gives you a completely different hash.
0; If you use a hash table that grows by increasing the result size by one bit, one old bucket maps across the entire new table, not to just two new buckets.
0; If your algorithm has a sliding pointer for which buckets have been split, that just won t work with FNV.
0; Second, it s linear.
0; That means that widely separated things can cancel each other out at least as easily as nearby things.
0; Third, since multiplication only affects higher bits, the lowest 7 bits of the state are never affected by the 8th bit of all the input bytes.
0;Hashing is a powerful and simple technique for accessing information.
0; Each key is mathematically converted into a number, which is then used as an index into a table.
0; In typical applications, it s common for two different keys to map to the same index, requiring some strategy for collision resolution.
0; However, many applications use a static set of records  for instance, the table of keywords for a compiler, the contents of a dictionary, or the topics in a help file.
0; In these cases, it s nice to have a perfect hashing function, one that maps different keys into different numbers.
0; With a perfect function, you could retrieve the record in exactly one probe, without worrying about collisions.
0; A special case of perfect hashing is minimal perfect hashing, where no empty locations in the table exist.
0; Minimal perfect hashing satisfies the ideal of fast performance and low memory usage.
0; However, finding perfect hashing functions is difficult.
0; In this article, I ll present a simple algorithm to find perfect hashing functions for a static set of data.
0;The BDZ algorithm uses r_uniform random hypergraphs given by function values of r uniform random hash functions on the input key set S for generating PHFs and MPHFs that require Obits to be stored.
0; A hypergraph is the generalization of a standard undirected graph where each edge connects vertices.
0; This idea is not new, see e.
0;g.
0; , but we have proceeded differently to achieve a space usage of Obits rather than Obits.
0; Evaluation time for all schemes considered is constant.
0; For r 3 we obtain a space usage of approximately 2.
0;6n bits for an MPHF.
0; More compact, and even simpler, representations can be achieved for larger m.
0; For example, for m 1.
0;23n we can get a space usage of 1.
0;95n bits.
