   
40                    
   
ÜTypesof data structures in as/400:
                                                           
                                                                       
                                                                                                                                   
DATA                            
STRUCTURE                       
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
                                                                                                                                    
                                                                                                                                   
                                                                                                                                   
                                                                                                                                    
                   
                                                                               
                                                                               
                                                                                                                                   
                                                     
                                                             
                                                                     
         
                                                                            
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
                                                                                                                                    
                                                                                                                                   
                                                                                                                                   
                                                   
                                                                                                                                                                                                                                                        
                                                                               
                        
                                                                               
                                                                                                                       
                                                                                                                                   
                                                                                                                                   
                                                                                                                                   
                                                                                                                       
                  



Answer / k.ramesh
Answer / k.ramesh







Data structure is specified in the Input Specification of an RPG 3 Program where as in RPG 1V we specified in 'D' specification. Data Structure is define an area in storage and layout related subfields. There are 4 types of data structures 1) Data Area Data Structure 2) File Information Data Structure 3) Program Status Data Structure 4) Multiple Occurence Data Structure Data Structure is used for 1) To break fields into subfields 2) To change the format of the field 3) To Group non-contiguous data into contiguous format 4) To convert data.
Data structure is specified in the Input Specification of an RPG 3 Program where as in RPG 1V we specified in 'D' specification. Data Structure is define an area in storage and layout related subfields. There are 4 types of data structures 1) Data Area Data Structure 2) File Information Data Structure 3) Program Status Data Structure 4) Multiple Occurence Data Structure Data Structure is used for 1) To break fields into subfields 2) To change the format of the field 3) To Group non-contiguous data into contiguous format 4) To convert data.
Data structure is specified in the Input Specification of an RPG 3 Program where as in RPG 1V we specified in 'D' specification. Data Structure is define an area in storage and layout related subfields. There are 4 types of data structures 1) Data Area Data Structure 2) File Information Data Structure 3) Program Status Data Structure 4) Multiple Occurence Data Structure Data Structure is used for 1) To break fields into subfields 2) To change the format of the field 3) To Group non-contiguous data into contiguous format 4) To convert data.














I have been racking my brain to try to remember when I first came across Externally Described Data Structures in RPG. I think it must have been when I transitioned from being a RPG II programmer on the IBM System/36 to a RPG III programmer on an AS400 (yes, I am that old). The others I was working with at the time were all former IBM System/38 programmers and were "fluent" in RPG III. They did not use Externally Described Data Structures. and I was the "newbie" learning RPG III from them, so neither did I.
I have been racking my brain to try to remember when I first came across Externally Described Data Structures in RPG. I think it must have been when I transitioned from being a RPG II programmer on the IBM System/36 to a RPG III programmer on an AS400 (yes, I am that old). The others I was working with at the time were all former IBM System/38 programmers and were "fluent" in RPG III. They did not use Externally Described Data Structures. and I was the "newbie" learning RPG III from them, so neither did I.
I have been racking my brain to try to remember when I first came across Externally Described Data Structures in RPG. I think it must have been when I transitioned from being a RPG II programmer on the IBM System/36 to a RPG III programmer on an AS400 (yes, I am that old). The others I was working with at the time were all former IBM System/38 programmers and were "fluent" in RPG III. They did not use Externally Described Data Structures. and I was the "newbie" learning RPG III from them, so neither did I.
I have been racking my brain to try to remember when I first came across Externally Described Data Structures in RPG. I think it must have been when I transitioned from being a RPG II programmer on the IBM System/36 to a RPG III programmer on an AS400 (yes, I am that old). The others I was working with at the time were all former IBM System/38 programmers and were "fluent" in RPG III. They did not use Externally Described Data Structures. and I was the "newbie" learning RPG III from them, so neither did I.
I have been racking my brain to try to remember when I first came across Externally Described Data Structures in RPG. I think it must have been when I transitioned from being a RPG II programmer on the IBM System/36 to a RPG III programmer on an AS400 (yes, I am that old). The others I was working with at the time were all former IBM System/38 programmers and were "fluent" in RPG III. They did not use Externally Described Data Structures. and I was the "newbie" learning RPG III from them, so neither did I.
Warning:  If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS.
Warning:  If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS.
Warning:  If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS.
Warning:  If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS.
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
Externally described data structures can be used in a myriad of ways and this was available when the System/38 was released externally to IBM Rochester, MN it was availiabel to RPG III and COBOL for sure. Being on the design/implementation team with the Lanuguage and Utilities team, I should know. You mentioned the following Warning: If you convert a RPG III program using the CVTRPGSRC command and the source member contains the PSDS as an Externally described DS the conversion will complete successfully. But as the layout of the RPGIII and RPGLE/RPGIV PSDS are different you are going to have run-time issues. You need to change the new source member to use a RPGLE/RPG IV compatible PSDS. I would suggest, when you transition for the System/38 PSDS to the newer one, remember to use the compiler statements along with the conditional compiler statements to compile based on your target release and your target system level, if you have not already done so. This does not take much change in the coding, it only requires you have planned this out ahead of time, so if you are supporting code to a larger base or customer set, you don't need to keep so many different copies per level. Happy times are when you have a plan and it works going forward and not just for the moment...
*******************
*******************
The QUALIFIED keyword finally gives us the ability to use the same subfield name in more than one data structure. This is because the data structure is qualified and the subfields may only be referred to using qualified syntax. Because of this, the compiler can distinguish between the subfield names from different data structures. That is, CUSTOMER.CUSTNO is different from UNDO_BUFFER.CUSTNO.
The QUALIFIED keyword finally gives us the ability to use the same subfield name in more than one data structure. This is because the data structure is qualified and the subfields may only be referred to using qualified syntax. Because of this, the compiler can distinguish between the subfield names from different data structures. That is, CUSTOMER.CUSTNO is different from UNDO_BUFFER.CUSTNO.
The QUALIFIED keyword finally gives us the ability to use the same subfield name in more than one data structure. This is because the data structure is qualified and the subfields may only be referred to using qualified syntax. Because of this, the compiler can distinguish between the subfield names from different data structures. That is, CUSTOMER.CUSTNO is different from UNDO_BUFFER.CUSTNO.
The QUALIFIED keyword finally gives us the ability to use the same subfield name in more than one data structure. This is because the data structure is qualified and the subfields may only be referred to using qualified syntax. Because of this, the compiler can distinguish between the subfield names from different data structures. That is, CUSTOMER.CUSTNO is different from UNDO_BUFFER.CUSTNO.
The QUALIFIED keyword finally gives us the ability to use the same subfield name in more than one data structure. This is because the data structure is qualified and the subfields may only be referred to using qualified syntax. Because of this, the compiler can distinguish between the subfield names from different data structures. That is, CUSTOMER.CUSTNO is different from UNDO_BUFFER.CUSTNO.
The QUALIFIED keyword finally gives us the ability to use the same subfield name in more than one data structure. This is because the data structure is qualified and the subfields may only be referred to using qualified syntax. Because of this, the compiler can distinguish between the subfield names from different data structures. That is, CUSTOMER.CUSTNO is different from UNDO_BUFFER.CUSTNO.
V5R1 of OS/400 saw the introduction of qualified data structures and the LIKEDS keyword in RPG IV. At first glance these appeared to be "neat" enhancements but not something to get too excited about. But, when you start to use them you discover that qualified data structures have a lot more to offer then just a "beefed up" means of prefixing field names. They allow you to use the same field name in multiple structures without name conflict, provide a means of defining standard structures (the most obvious use of this is for APIs), and they lead to self documenting code.
V5R1 of OS/400 saw the introduction of qualified data structures and the LIKEDS keyword in RPG IV. At first glance these appeared to be "neat" enhancements but not something to get too excited about. But, when you start to use them you discover that qualified data structures have a lot more to offer then just a "beefed up" means of prefixing field names. They allow you to use the same field name in multiple structures without name conflict, provide a means of defining standard structures (the most obvious use of this is for APIs), and they lead to self documenting code.
V5R1 of OS/400 saw the introduction of qualified data structures and the LIKEDS keyword in RPG IV. At first glance these appeared to be "neat" enhancements but not something to get too excited about. But, when you start to use them you discover that qualified data structures have a lot more to offer then just a "beefed up" means of prefixing field names. They allow you to use the same field name in multiple structures without name conflict, provide a means of defining standard structures (the most obvious use of this is for APIs), and they lead to self documenting code.
V5R1 of OS/400 saw the introduction of qualified data structures and the LIKEDS keyword in RPG IV. At first glance these appeared to be "neat" enhancements but not something to get too excited about. But, when you start to use them you discover that qualified data structures have a lot more to offer then just a "beefed up" means of prefixing field names. They allow you to use the same field name in multiple structures without name conflict, provide a means of defining standard structures (the most obvious use of this is for APIs), and they lead to self documenting code.












----------------------------------- About the author: Paul Tuohy is CEO of ComCon, an iSeries consulting company. He is the author of "Re-engineering RPG Legacy Applications", "The Programmers Guide to iSeries Navigator" and the self teach course "iSeries Navigator for Programmers". He is also an award winning speaker who speaks regularly at US Common conferences and the renowned RPG World conferences.  
----------------------------------- About the author: Paul Tuohy is CEO of ComCon, an iSeries consulting company. He is the author of "Re-engineering RPG Legacy Applications", "The Programmers Guide to iSeries Navigator" and the self teach course "iSeries Navigator for Programmers". He is also an award winning speaker who speaks regularly at US Common conferences and the renowned RPG World conferences.  
----------------------------------- About the author: Paul Tuohy is CEO of ComCon, an iSeries consulting company. He is the author of "Re-engineering RPG Legacy Applications", "The Programmers Guide to iSeries Navigator" and the self teach course "iSeries Navigator for Programmers". He is also an award winning speaker who speaks regularly at US Common conferences and the renowned RPG World conferences.  
----------------------------------- About the author: Paul Tuohy is CEO of ComCon, an iSeries consulting company. He is the author of "Re-engineering RPG Legacy Applications", "The Programmers Guide to iSeries Navigator" and the self teach course "iSeries Navigator for Programmers". He is also an award winning speaker who speaks regularly at US Common conferences and the renowned RPG World conferences.  
----------------------------------- About the author: Paul Tuohy is CEO of ComCon, an iSeries consulting company. He is the author of "Re-engineering RPG Legacy Applications", "The Programmers Guide to iSeries Navigator" and the self teach course "iSeries Navigator for Programmers". He is also an award winning speaker who speaks regularly at US Common conferences and the renowned RPG World conferences.  


























An externally described data structure uses an externally described file definition to define the data structure, it is used to retrieve the field definitions from the file at compile time and create a data structure in your program based upon those field definitions.










