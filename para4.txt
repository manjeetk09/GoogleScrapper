My questions are: What is message passing? (Can someone give a practical example?). Is there any support for this "message passing" in C++, C# or Java?.
My questions are: What is message passing? (Can someone give a practical example?). Is there any support for this "message passing" in C++, C# or Java?.
My questions are: What is message passing? (Can someone give a practical example?). Is there any support for this "message passing" in C++, C# or Java?.
Is there any support for this "message passing" in C++, C# or Java?
An example in Groovy that demonstrates the power of this concept:
In computer science, message passing sends a message to a process (which may be an actor or object) and relies on the process and the supporting infrastructure to select and invoke the actual code to run. Message passing differs from conventional programming where a process, subroutine, or function is directly invoked by name. Message passing is key to some models of concurrency and object-oriented programming.
In computer science, message passing sends a message to a process (which may be an actor or object) and relies on the process and the supporting infrastructure to select and invoke the actual code to run. Message passing differs from conventional programming where a process, subroutine, or function is directly invoked by name. Message passing is key to some models of concurrency and object-oriented programming.
In computer science, message passing sends a message to a process (which may be an actor or object) and relies on the process and the supporting infrastructure to select and invoke the actual code to run. Message passing differs from conventional programming where a process, subroutine, or function is directly invoked by name. Message passing is key to some models of concurrency and object-oriented programming.


One of the first examples of how this can be used was in the domain of computer graphics. There are all sorts of complexities involved in manipulating graphic objects. For example, simply using the right formula to compute the area of an enclosed shape will vary depending on if the shape is a triangle, rectangle, elipse, or circle. In traditional computer programming this would result in long IF-THEN statements testing what sort of object the shape was and calling the appropriate code. The object-oriented way to handle this is to define a class called Shape with subclasses such as Rectangle and Ellipse (which in turn have subclasses Square and Circle) and then to simply send a message to any Shape asking it to compute its area. Each Shape object will then invoke the way code with the formula appropriate for that kind of object.
One of the first examples of how this can be used was in the domain of computer graphics. There are all sorts of complexities involved in manipulating graphic objects. For example, simply using the right formula to compute the area of an enclosed shape will vary depending on if the shape is a triangle, rectangle, elipse, or circle. In traditional computer programming this would result in long IF-THEN statements testing what sort of object the shape was and calling the appropriate code. The object-oriented way to handle this is to define a class called Shape with subclasses such as Rectangle and Ellipse (which in turn have subclasses Square and Circle) and then to simply send a message to any Shape asking it to compute its area. Each Shape object will then invoke the way code with the formula appropriate for that kind of object.
One of the first examples of how this can be used was in the domain of computer graphics. There are all sorts of complexities involved in manipulating graphic objects. For example, simply using the right formula to compute the area of an enclosed shape will vary depending on if the shape is a triangle, rectangle, elipse, or circle. In traditional computer programming this would result in long IF-THEN statements testing what sort of object the shape was and calling the appropriate code. The object-oriented way to handle this is to define a class called Shape with subclasses such as Rectangle and Ellipse (which in turn have subclasses Square and Circle) and then to simply send a message to any Shape asking it to compute its area. Each Shape object will then invoke the way code with the formula appropriate for that kind of object.
One of the first examples of how this can be used was in the domain of computer graphics. There are all sorts of complexities involved in manipulating graphic objects. For example, simply using the right formula to compute the area of an enclosed shape will vary depending on if the shape is a triangle, rectangle, elipse, or circle. In traditional computer programming this would result in long IF-THEN statements testing what sort of object the shape was and calling the appropriate code. The object-oriented way to handle this is to define a class called Shape with subclasses such as Rectangle and Ellipse (which in turn have subclasses Square and Circle) and then to simply send a message to any Shape asking it to compute its area. Each Shape object will then invoke the way code with the formula appropriate for that kind of object.
One of the first examples of how this can be used was in the domain of computer graphics. There are all sorts of complexities involved in manipulating graphic objects. For example, simply using the right formula to compute the area of an enclosed shape will vary depending on if the shape is a triangle, rectangle, elipse, or circle. In traditional computer programming this would result in long IF-THEN statements testing what sort of object the shape was and calling the appropriate code. The object-oriented way to handle this is to define a class called Shape with subclasses such as Rectangle and Ellipse (which in turn have subclasses Square and Circle) and then to simply send a message to any Shape asking it to compute its area. Each Shape object will then invoke the way code with the formula appropriate for that kind of object.
One of the first examples of how this can be used was in the domain of computer graphics. There are all sorts of complexities involved in manipulating graphic objects. For example, simply using the right formula to compute the area of an enclosed shape will vary depending on if the shape is a triangle, rectangle, elipse, or circle. In traditional computer programming this would result in long IF-THEN statements testing what sort of object the shape was and calling the appropriate code. The object-oriented way to handle this is to define a class called Shape with subclasses such as Rectangle and Ellipse (which in turn have subclasses Square and Circle) and then to simply send a message to any Shape asking it to compute its area. Each Shape object will then invoke the way code with the formula appropriate for that kind of object.


Synchronous message passing is what typical object-oriented programming languages such as Java and Smalltalk use. Asynchronous message passing requires additional capabilities for storing and retransmitting data for systems that may not run concurrently.
Synchronous message passing is what typical object-oriented programming languages such as Java and Smalltalk use. Asynchronous message passing requires additional capabilities for storing and retransmitting data for systems that may not run concurrently.




May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
May 2017 (17) April 2017 (27) March 2017 (12) February 2017 (18) January 2017 (44) December 2016 (23) November 2016 (13) October 2016 (1) September 2016 (55) August 2016 (31) July 2016 (50) June 2016 (66) May 2016 (103) April 2016 (6)
The messages are send and received by passing various variables among specific methods using the signature ( a term that is not prevalent in common parlance) of the methods. Every methods has a well defined and structured signature. The signature of a method is composed of (1) a type, associated with the variable whose value after execution of the method, would be returned to the object that would invoke the method; (2) the types of a specific number of variables and the order associated with these variables whose values would be passed to the method before execution of the method starts. All these variables have a well defined format and corresponding values at any instant of time available for communication during the execution of the program. Figure below shows an example of a signature for a method ‘evaluate’.
The messages are send and received by passing various variables among specific methods using the signature ( a term that is not prevalent in common parlance) of the methods. Every methods has a well defined and structured signature. The signature of a method is composed of (1) a type, associated with the variable whose value after execution of the method, would be returned to the object that would invoke the method; (2) the types of a specific number of variables and the order associated with these variables whose values would be passed to the method before execution of the method starts. All these variables have a well defined format and corresponding values at any instant of time available for communication during the execution of the program. Figure below shows an example of a signature for a method ‘evaluate’.
The messages are send and received by passing various variables among specific methods using the signature ( a term that is not prevalent in common parlance) of the methods. Every methods has a well defined and structured signature. The signature of a method is composed of (1) a type, associated with the variable whose value after execution of the method, would be returned to the object that would invoke the method; (2) the types of a specific number of variables and the order associated with these variables whose values would be passed to the method before execution of the method starts. All these variables have a well defined format and corresponding values at any instant of time available for communication during the execution of the program. Figure below shows an example of a signature for a method ‘evaluate’.
The messages are send and received by passing various variables among specific methods using the signature ( a term that is not prevalent in common parlance) of the methods. Every methods has a well defined and structured signature. The signature of a method is composed of (1) a type, associated with the variable whose value after execution of the method, would be returned to the object that would invoke the method; (2) the types of a specific number of variables and the order associated with these variables whose values would be passed to the method before execution of the method starts. All these variables have a well defined format and corresponding values at any instant of time available for communication during the execution of the program. Figure below shows an example of a signature for a method ‘evaluate’.
The messages are send and received by passing various variables among specific methods using the signature ( a term that is not prevalent in common parlance) of the methods. Every methods has a well defined and structured signature. The signature of a method is composed of (1) a type, associated with the variable whose value after execution of the method, would be returned to the object that would invoke the method; (2) the types of a specific number of variables and the order associated with these variables whose values would be passed to the method before execution of the method starts. All these variables have a well defined format and corresponding values at any instant of time available for communication during the execution of the program. Figure below shows an example of a signature for a method ‘evaluate’.
Message passing is a type of communication between processes or objects in computer science. In this model, processes or objects can send and receive messages (signals, functions, complex data structures, or data packets) to other processes or objects.
Message passing is a type of communication between processes or objects in computer science. In this model, processes or objects can send and receive messages (signals, functions, complex data structures, or data packets) to other processes or objects.
If we are talking about OOP than the term "message passing" comes from Smalltalk. In a few words the Smalltalk basic principles are:
If we are talking about OOP than the term "message passing" comes from Smalltalk. In a few words the Smalltalk basic principles are:
I think this terms are more or less equivalent. May be the only interesting difference is that message passing (at least in Smalltalk) always rely on dynamic dispatch and late binding while in the case of method invocation one can use static dispatch and early binding too. For example, C++ (AFAIK) does early binding by default until "virtual" keyword appears somewhere...
I think this terms are more or less equivalent. May be the only interesting difference is that message passing (at least in Smalltalk) always rely on dynamic dispatch and late binding while in the case of method invocation one can use static dispatch and early binding too. For example, C++ (AFAIK) does early binding by default until "virtual" keyword appears somewhere...
I think this terms are more or less equivalent. May be the only interesting difference is that message passing (at least in Smalltalk) always rely on dynamic dispatch and late binding while in the case of method invocation one can use static dispatch and early binding too. For example, C++ (AFAIK) does early binding by default until "virtual" keyword appears somewhere...
Anyway, regardless of which formalism do your programming language use for communication between two objects (message passing or method invocation) it's always considered a good OOP style to forbid direct access to instance variables in Smalltalk terminology or data members in C++ terminology or whatever term is used in your programming language.
