In this traversal method, the left subtree is visited first, then the root and later the right sub_tree.
 We should always remember that every node may represent a subtree itself.
If a binary tree is traversed in_order, the output will produce sorted key values in an ascending order.
In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.
.
.
These searches are referred to as depth_first search , as the search tree is deepened as much as possible on each child before going to the next sibling.
 For a binary tree, they are defined as display operations recursively at each node, starting with the root, whose algorithm is as follows: .
.
.
.
.
Recursively traverse its left subtree.
 When this step is finished you are back at N again.
.
.
Unlike linear data structures which have only one logical way to traverse them, trees can be traversed in different ways.
 Following are the generally used ways for traversing trees.
.
.
Displaying visiting order of nodes in a binary tree is called as Binary Tree Traversal.
There are three types of binary tree traversals.
Now that we have examined the basic functionality of our tree data structure, it is time to look at some additional usage patterns for trees.
 These usage patterns can be divided into the three ways that we access the nodes of the tree.
 There are three commonly used patterns to visit all the nodes in a tree.
 The difference between these patterns is the order in which each node is visited.
 We call this visitation of the nodes a “traversal.
” The three traversals we will look at are called preorder, inorder, and postorder.
 Let’s start out by defining these three traversals more carefully, then look at some examples where these patterns are useful.
Let’s look at some examples that illustrate each of these three kinds of traversals.
 First let’s look at the preorder traversal.
 As an example of a tree to traverse, we will represent this book as a tree.
 The book is the root of the tree, and each chapter is a child of the root.
 Each section within a chapter is a child of the chapter, and each subsection is a child of its section, and so on.
 Figure 5 shows a limited version of a book with only two chapters.
 Note that the traversal algorithm works for trees with any number of children, but we will stick with binary trees for now.
.
.
.
.
Traversing a tree in breadth_first order means that after visiting a node X, all of X's children are visited, then all of X's 'grand_children' (i.
e.
 the children's children), then all of X's 'great_grand_children', etc.
 In other words, the tree is traversed by sweeping through the breadth of a level before visiting the next level down, as shown in this animation:.
.
.
.
.
.
.
.
.
which can be implemented as follows, using the tree data structure defined in the previous unit:.
which can be implemented as:.
which can be implemented as:.
.
.
.
.
.
.
.
.
.
.
.
What I've just called ``scanning through'' a tree is actually called traversing a tree.
.
.
.
.
.
.
For a specific data structure, we talk about the different orders in which it might be traversed.
 For a list there are two common traversal orders: first_to_last and last_to_first.
.
.
.
.
.
.
Unlike linear data structures like Array, Linked List, Queues, Stacks etc.
 which have only one logical way to traverse them, trees can be traversed in 2 different ways.
Depth First Traversal : Traverse depth wise . It includes these three_.
.
What is the difference between a AVL tree and a binary search tree?.
What are the advantages of B+ Trees over B Trees?.
What is traversing?.
What is the difference between a tree and a forest in graph theory?.
What is the difference between a tree, a prefix tree, and a radix tree?.
Does the order in a B_tree change as we traverse down the levels?.
How do tries differ from binary search trees?.
What is the difference between MHR_tree and R_tree?.
How do I perform a post_order traversal on a binary tree?.
How does the technique of Binary Indexed Tree work and in what kind of problems is it useful?.
What is the difference between a binary tree and a regular binary tree?.
What is the techniques of indexing tree?.
Is there a way to do a BFS traversal of a binary tree with recursion ?.
How is a Huffman Tree different from an Optimal binary search tree?.
How do I remember preorder, postorder and inorder traversal?.
.
.
If you know that the tree has an inherent sequence in the nodes, and you want to flatten the tree back into its original sequence, than an in_order traversal should be used.
 The tree would be flattened in the same way it was created.
 A pre_order or post_order traversal might not unwind the tree back into the sequence which was used to create it.
.
.
General Definition: to traverse a tree data structure is to process, however you like, every node in the data structure exactly once.
.
For a specific tree data structure, we have different orders in which they might be traversed.
 So for the list abstract data structure there were two common traversal orders: first_to_last and last_to_first.
 This traversal method is applicable to all linear data structures.
 So now let us consider each approach on a sample binary tree.
 In the example tree the nodes are numbered in the order that they will be processed.
 We start off with the pre_order traversal.
.
We will examine how a common data structure can be used to help traverse a tree in breadth_first order.
.
.
.
.
.
.
.
.
.
Move the type definition for treeNodeT into queue.h. Then we could do: 
typedef treeNodeT *queueElementT;
 That would work since we'd get the type treeNodeT in tree.c when we include queue.h. It's not ideal though, since treeNodeT really belongs in the tree implementation file..
Leave treeNodeT in tree.c, but refer to it in queue.h. Remember that we can refer to a pointer to a structure that is not defined, as in: 
typedef struct treeNodeTag *queueElementT;
 As long as we don't try to dereference that pointer. That would work because the queue will just store these pointers, not dereference them..
Finally, we could use the generic pointer type, void *, as the element type. A void * can take on the value of any pointer , so we could use it to store the value of a treeNodeT *..
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
Move the type definition for treeNodeT into queue.h. Then we could do: 
typedef treeNodeT *queueElementT;
 That would work since we'd get the type treeNodeT in tree.c when we include queue.h. It's not ideal though, since treeNodeT really belongs in the tree implementation file..
Leave treeNodeT in tree.c, but refer to it in queue.h. Remember that we can refer to a pointer to a structure that is not defined, as in: 
typedef struct treeNodeTag *queueElementT;
 As long as we don't try to dereference that pointer. That would work because the queue will just store these pointers, not dereference them..
Finally, we could use the generic pointer type, void *, as the element type. A void * can take on the value of any pointer , so we could use it to store the value of a treeNodeT *..
.
.
.
.
.
.
Traversal is the method of processing each and every node in the Binary Search Tree exactly once in a systematic manner.
 There are three different types of tree traversal.
 Preorder Traversal In order Traversal Post order Traversal.
.
.
.
Algorithm:.
.
.
In the case of pointer to node, we have to explicitly allocate memory of node type to the pointer.
 .
.
